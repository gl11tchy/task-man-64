import * as db from './db.js';
import { TaskWithColumns } from './db.js';
import * as git from './git.js';
import * as github from './github.js';
import * as claude from './claude.js';
import * as events from './events.js';
import { CONFIG } from './config.js';

export async function processNewTask(task: TaskWithColumns): Promise<void> {
  const branchName = `autoclaude/${task.id.slice(0, 8)}`;
  const isRetry = (task.attempt_count ?? 0) > 0;

  console.log(`\n${'='.repeat(60)}`);
  console.log(`[${task.id}] Processing${isRetry ? ' (retry)' : ''}: ${task.text.slice(0, 50)}...`);
  console.log(`${'='.repeat(60)}\n`);

  // Emit: task started
  await events.emitEvent(
    task.project_id as string,
    'task_started',
    `Processing: ${task.text.slice(0, 60)}${task.text.length > 60 ? '...' : ''}`,
    task.id,
    { isRetry, attemptCount: task.attempt_count }
  );

  try {
    // 1. Clone/pull repo
    console.log(`[${task.id}] Cloning repo...`);
    await events.emitEvent(task.project_id as string, 'cloning_repo', `Cloning repository...`, task.id);
    const workDir = await git.cloneOrPull(task.repo_url, task.id);

    // 2. Create branch
    console.log(`[${task.id}] Creating branch ${branchName}...`);
    await events.emitEvent(task.project_id as string, 'creating_branch', `Creating branch: ${branchName}`, task.id);
    await git.createBranch(workDir, branchName);

    // 3. Run Claude
    console.log(`[${task.id}] Running Claude...`);
    await events.emitEvent(task.project_id as string, 'running_claude', 'Running Claude to implement changes...', task.id);
    const result = await claude.runClaude(workDir, task.text);

    if (!result.success) {
      throw new Error(`Claude failed: ${result.error}`);
    }

    // 4. Commit and push (force on retry to handle diverged branches)
    console.log(`[${task.id}] Committing and pushing...`);
    await events.emitEvent(task.project_id as string, 'committing', 'Committing and pushing changes...', task.id);
    const commitResult = await git.commitAndPush(
      workDir,
      `autoclaude: ${task.text.slice(0, 50)}`,
      branchName,
      isRetry // Force push on retry
    );

    // 5. Check if changes were made before creating PR
    if (!commitResult.committed) {
      throw new Error('Claude made no changes to the codebase. The task may need clarification or already be complete.');
    }

    // 6. Create PR (or get existing one if retry)
    console.log(`[${task.id}] Creating PR...`);
    await events.emitEvent(task.project_id as string, 'creating_pr', 'Creating pull request...', task.id);
    let prUrl: string;
    try {
      prUrl = await github.createPR(
        workDir,
        `[AUTOCLAUDE] ${task.text.slice(0, 60)}`,
        `## Task\n${task.text}\n\n## Generated by AUTOCLAUDE\nTask ID: ${task.id}`,
        branchName
      );
    } catch (prError) {
      // PR might already exist from a previous retry attempt
      const existingPr = await github.getPRUrl(workDir, branchName);
      if (existingPr) {
        console.log(`[${task.id}] Using existing PR: ${existingPr}`);
        prUrl = existingPr;
      } else {
        throw prError;
      }
    }

    // 7. Mark resolved
    console.log(`[${task.id}] Done! PR: ${prUrl}`);
    await events.emitEvent(
      task.project_id as string,
      'task_completed',
      `Task completed! PR: ${prUrl}`,
      task.id,
      { prUrl }
    );
    await db.resolveTask(task.id, prUrl, task.columns.resolved);

    // 8. Cleanup work directory on success
    if (CONFIG.CLEANUP_ON_SUCCESS) {
      console.log(`[${task.id}] Cleaning up work directory...`);
      git.cleanupWorkDir(task.id);
    }

  } catch (error) {
    console.error(`[${task.id}] Error:`, error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    
    await events.emitEvent(
      task.project_id as string,
      'task_failed',
      `Failed: ${errorMessage.slice(0, 100)}`,
      task.id,
      { error: errorMessage }
    );
    await db.recordError(task.id, errorMessage, task.columns.backlog);
    // Keep work directory on error for debugging
  }
}

export async function processFeedbackTask(task: TaskWithColumns): Promise<void> {
  const branchName = `autoclaude/${task.id.slice(0, 8)}`;
  const isRetry = (task.attempt_count ?? 0) > 0;

  console.log(`\n${'='.repeat(60)}`);
  console.log(`[${task.id}] Processing feedback${isRetry ? ' (retry)' : ''}: ${task.feedback?.slice(0, 50)}...`);
  console.log(`${'='.repeat(60)}\n`);

  // Emit: feedback started
  await events.emitEvent(
    task.project_id as string,
    'feedback_started',
    `Addressing feedback: ${task.feedback?.slice(0, 60)}...`,
    task.id,
    { isRetry }
  );

  try {
    // 1. Get existing work dir or clone
    await events.emitEvent(task.project_id as string, 'cloning_repo', 'Syncing repository...', task.id);
    const workDir = await git.cloneOrPull(task.repo_url, task.id);

    // 2. Checkout existing branch
    console.log(`[${task.id}] Checking out branch ${branchName}...`);
    await events.emitEvent(task.project_id as string, 'creating_branch', `Checking out branch: ${branchName}`, task.id);
    await git.checkoutBranch(workDir, branchName);

    // 3. Run Claude with feedback context
    console.log(`[${task.id}] Running Claude with feedback...`);
    await events.emitEvent(task.project_id as string, 'running_claude', 'Running Claude to address feedback...', task.id);
    const feedbackPrompt = `
Original task: ${task.text}

The reviewer has requested changes. Their feedback:
${task.feedback}

Please address this feedback and make the necessary changes.
`;

    const result = await claude.runClaude(workDir, feedbackPrompt);

    if (!result.success) {
      throw new Error(`Claude failed: ${result.error}`);
    }

    // 4. Commit and push (to existing PR, force on retry to handle diverged branches)
    console.log(`[${task.id}] Pushing feedback fixes...`);
    await events.emitEvent(task.project_id as string, 'committing', 'Pushing feedback fixes...', task.id);
    const commitResult = await git.commitAndPush(workDir, `autoclaude: address feedback`, branchName, isRetry);

    // 5. Add comment to PR (even if no changes, to acknowledge the feedback)
    if (task.pr_url) {
      console.log(`[${task.id}] Adding comment to PR...`);
      const commentText = commitResult.committed
        ? `## Feedback Addressed\n\nI've addressed the feedback:\n> ${task.feedback?.replace(/\n/g, '\n> ')}\n\nPlease review the latest changes.`
        : `## Feedback Reviewed\n\nI reviewed the feedback:\n> ${task.feedback?.replace(/\n/g, '\n> ')}\n\nNo code changes were needed. The existing implementation already handles this, or the feedback requires clarification.`;

      await github.addPRComment(workDir, branchName, commentText);
    }

    // 6. Move back to resolved
    console.log(`[${task.id}] Feedback addressed!`);
    await events.emitEvent(
      task.project_id as string,
      'feedback_completed',
      'Feedback addressed successfully!',
      task.id,
      { prUrl: task.pr_url }
    );
    await db.resolveTask(task.id, task.pr_url!, task.columns.resolved);

    // 7. Cleanup work directory on success
    if (CONFIG.CLEANUP_ON_SUCCESS) {
      console.log(`[${task.id}] Cleaning up work directory...`);
      git.cleanupWorkDir(task.id);
    }

  } catch (error) {
    console.error(`[${task.id}] Error:`, error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    
    await events.emitEvent(
      task.project_id as string,
      'task_failed',
      `Feedback failed: ${errorMessage.slice(0, 100)}`,
      task.id,
      { error: errorMessage }
    );
    // Use recordFeedbackError to keep task in IN_PROGRESS column
    await db.recordFeedbackError(task.id, errorMessage);
    // Keep work directory on error for debugging
  }
}

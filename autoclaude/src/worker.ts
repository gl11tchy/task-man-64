import * as db from './db.js';
import * as git from './git.js';
import * as github from './github.js';
import * as claude from './claude.js';
import { TaskWithRepo } from './types.js';

export async function processNewTask(task: TaskWithRepo): Promise<void> {
  const branchName = `autoclaude/${task.id.slice(0, 8)}`;

  console.log(`\n${'='.repeat(60)}`);
  console.log(`[${task.id}] Processing: ${task.text.slice(0, 50)}...`);
  console.log(`${'='.repeat(60)}\n`);

  try {
    // 1. Clone/pull repo
    console.log(`[${task.id}] Cloning repo...`);
    const workDir = await git.cloneOrPull(task.repo_url, task.id);

    // 2. Create branch
    console.log(`[${task.id}] Creating branch ${branchName}...`);
    await git.createBranch(workDir, branchName);

    // 3. Run Claude
    console.log(`[${task.id}] Running Claude...`);
    const result = await claude.runClaude(workDir, task.text);

    if (!result.success) {
      throw new Error(`Claude failed: ${result.error}`);
    }

    // 4. Commit and push
    console.log(`[${task.id}] Committing and pushing...`);
    const commitResult = await git.commitAndPush(workDir, `autoclaude: ${task.text.slice(0, 50)}`, branchName);

    // 5. Check if changes were made before creating PR
    if (!commitResult.committed) {
      throw new Error('Claude made no changes to the codebase. The task may need clarification or already be complete.');
    }

    // 6. Create PR
    console.log(`[${task.id}] Creating PR...`);
    const prUrl = await github.createPR(
      workDir,
      `[AUTOCLAUDE] ${task.text.slice(0, 60)}`,
      `## Task\n${task.text}\n\n## Generated by AUTOCLAUDE\nTask ID: ${task.id}`,
      branchName
    );

    // 7. Mark resolved
    console.log(`[${task.id}] Done! PR: ${prUrl}`);
    await db.resolveTask(task.id, prUrl);

  } catch (error) {
    console.error(`[${task.id}] Error:`, error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    await db.recordError(task.id, errorMessage);
  }
}

export async function processFeedbackTask(task: TaskWithRepo): Promise<void> {
  const branchName = `autoclaude/${task.id.slice(0, 8)}`;

  console.log(`\n${'='.repeat(60)}`);
  console.log(`[${task.id}] Processing feedback: ${task.feedback?.slice(0, 50)}...`);
  console.log(`${'='.repeat(60)}\n`);

  try {
    // 1. Get existing work dir or clone
    const workDir = await git.cloneOrPull(task.repo_url, task.id);

    // 2. Checkout existing branch
    console.log(`[${task.id}] Checking out branch ${branchName}...`);
    await git.checkoutBranch(workDir, branchName);

    // 3. Run Claude with feedback context
    console.log(`[${task.id}] Running Claude with feedback...`);
    const feedbackPrompt = `
Original task: ${task.text}

The reviewer has requested changes. Their feedback:
${task.feedback}

Please address this feedback and make the necessary changes.
`;

    const result = await claude.runClaude(workDir, feedbackPrompt);

    if (!result.success) {
      throw new Error(`Claude failed: ${result.error}`);
    }

    // 4. Commit and push (to existing PR)
    console.log(`[${task.id}] Pushing feedback fixes...`);
    const commitResult = await git.commitAndPush(workDir, `autoclaude: address feedback`, branchName);

    // 5. Add comment to PR (even if no changes, to acknowledge the feedback)
    if (task.pr_url) {
      console.log(`[${task.id}] Adding comment to PR...`);
      const commentText = commitResult.committed
        ? `## Feedback Addressed\n\nI've addressed the feedback:\n> ${task.feedback?.replace(/\n/g, '\n> ')}\n\nPlease review the latest changes.`
        : `## Feedback Reviewed\n\nI reviewed the feedback:\n> ${task.feedback?.replace(/\n/g, '\n> ')}\n\nNo code changes were needed. The existing implementation already handles this, or the feedback requires clarification.`;

      await github.addPRComment(workDir, branchName, commentText);
    }

    // 6. Clear feedback and move back to resolved
    console.log(`[${task.id}] Feedback addressed!`);
    await db.clearFeedback(task.id);
    await db.resolveTask(task.id, task.pr_url!);

  } catch (error) {
    console.error(`[${task.id}] Error:`, error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    await db.recordError(task.id, errorMessage);
  }
}
